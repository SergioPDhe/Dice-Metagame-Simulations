{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import pandas as pd\n",
    "directory = \"C:/Users/Sergio/Documents/python projects/Dice/\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Die: # \n",
    "    def __init__(self,sides): \n",
    "        self.sides = sides #sides specified as an array at initialization\n",
    "        \n",
    "        self.wins = 0 #how many MUs it wins/draws/loses\n",
    "        self.losses = 0\n",
    "        self.contests = 0\n",
    "        \n",
    "        self.possWins = 0 #how many possible interactions it wins/draws/loses\n",
    "        self.possLosses = 0\n",
    "        self.possContests = 0\n",
    "        \n",
    "    def show(self): #print info for die\n",
    "        draws = self.contests - (self.wins + self.losses)\n",
    "        possDraws = self.possContests - (self.possWins + self.possLosses)\n",
    "        \n",
    "        winPercent = str(100*self.wins/self.contests)[0:6] + \"%\"\n",
    "        drawPercent = str(100*draws/self.contests)[0:6] + \"%\"\n",
    "        lossPercent = str(100*self.losses/self.contests)[0:6] + \"%\"\n",
    "        \n",
    "        possWinPercent = str(100*self.possWins/self.possContests)[0:6] + \"%\"\n",
    "        possDrawPercent = str(100*possDraws/self.possContests)[0:6] + \"%\"\n",
    "        possLossPercent = str(100*self.possLosses/self.possContests)[0:6] + \"%\"\n",
    "               \n",
    "        \n",
    "        print(self.sides,end = \"\\t\")\n",
    "        print(str(self.wins) + \"\\t\" + str(draws) + \"\\t\" + str(self.losses),end = \"\\t\")\n",
    "        print(winPercent + \"\\t\" + drawPercent + \"\\t\" + lossPercent,end = \"\\t\")\n",
    "        \n",
    "        print(str(self.possWins) + \"\\t\" + str(possDraws) + \"\\t\" + str(self.possLosses),end = \"\\t\")\n",
    "        print(possWinPercent + \"\\t\" + possDrawPercent + \"\\t\" + possLossPercent,end = \"\\t\")\n",
    "        \n",
    "        print()\n",
    "\n",
    "        \n",
    "    def play(self):\n",
    "        self.contests = self.contests + 1\n",
    "    \n",
    "    def win(self):\n",
    "        self.wins = self.wins+1\n",
    "        \n",
    "    def lose(self):\n",
    "        self.losses = self.losses+1\n",
    "        \n",
    "    def roll(self):\n",
    "        return random.choice(self.sides)\n",
    "    \n",
    "    def half(self): # divides attributes by 2 since all values are doubled when calculated\n",
    "        self.wins /= 2\n",
    "        self.losses /= 2\n",
    "        self.contests /= 2\n",
    "        \n",
    "        self.possWins /= 2\n",
    "        self.possLosses /= 2\n",
    "        self.possContests /= 2\n",
    "        \n",
    "    def clearMatches(self): # reset matches data\n",
    "        self.wins = 0\n",
    "        self.losses = 0\n",
    "        self.contests = 0\n",
    "        \n",
    "        self.possWins = 0\n",
    "        self.possLosses = 0\n",
    "        self.possContests = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "class AllDice:# set of dice\n",
    "    def __init__(self):\n",
    "        self.dice = [] # dice in set as array of dice\n",
    "        self.build() # build a set of every possible die\n",
    "        #self.show()\n",
    "        \n",
    "    def build(self):# every [possible 6-sided die with 21 total]\n",
    "        for a in range(4,22):# largest number in the dice can only be between 4 and 21 ([4,4,4,3,3,3] to [21,0,0,0,0,0])\n",
    "            for b in range(11):# second largest number can only be as high as 10 [11,10,0,0,0,0]\n",
    "                if a<b:\n",
    "                    break # if the 2nd number is greater than the 1st, quit out of loop\n",
    "                for c in range(8):# 3rd number goes up to 7 [7,7,7,0,0,0]\n",
    "                    if b<c:\n",
    "                        break\n",
    "                    for d in range(6):# 4th number goes to 5 [6,5,5,5,0,0]\n",
    "                        if c<d:\n",
    "                            break\n",
    "                        for e in range(5):# and so on [5,4,4,4,4,0]\n",
    "                            if d<e:\n",
    "                                break\n",
    "                            for f in range(4):# [4,4,4,3,3,3]\n",
    "                                if e<f:\n",
    "                                    break\n",
    "                                if (a+b+c+d+e+f)==21:# only add to list if numbers add to 21\n",
    "                                    self.dice.append(Die([a,b,c,d,e,f]))\n",
    "                                    \n",
    "    def show(self):# print data for every die in table-friendly manner\n",
    "        #print(len(self.dice))\n",
    "        print(\"sides\",end = \"\\t\")\n",
    "        \n",
    "        print(\"MU wins\",end = \"\\t\")\n",
    "        print(\"MU draws\",end = \"\\t\")\n",
    "        print(\"MU losses\",end = \"\\t\")\n",
    "        print(\"MU win %\",end = \"\\t\")\n",
    "        print(\"MU draw %\",end = \"\\t\")\n",
    "        print(\"MU loss %\",end = \"\\t\")\n",
    "        \n",
    "        print(\"total wins\",end = \"\\t\")\n",
    "        print(\"total draw\",end = \"\\t\")\n",
    "        print(\"total losses\",end = \"\\t\")\n",
    "        print(\"total win %\",end = \"\\t\")\n",
    "        print(\"total draws %\",end = \"\\t\")\n",
    "        print(\"total loss %\")\n",
    "        for i in self.dice:\n",
    "            i.half()\n",
    "            i.show()\n",
    "            \n",
    "    def clearMatches(self):\n",
    "        for i in self.dice:\n",
    "            i.clearMatches()       \n",
    "            \n",
    "    def fightAll(self): # analyze all dice by comparing them to each other twice\n",
    "        for i in self.dice:\n",
    "            for j in self.dice:\n",
    "                Contest(i,j)\n",
    "                \n",
    "    def limitMU(self,limit): # removes dice below a certain MU win % (not used)\n",
    "        passList = []\n",
    "        for i in self.dice:\n",
    "            if (i.wins/i.contests) >= limit:\n",
    "                passList.append(i)\n",
    "            self.dice = passList\n",
    "            \n",
    "    def limitTotal(self,limit): # removes dice below a certain possible interaction win % (not used)\n",
    "        passList = []\n",
    "        for i in self.dice:\n",
    "            if (i.possWins/i.possContests) >= limit:\n",
    "                passList.append(i)\n",
    "            self.dice = passList\n",
    "            \n",
    "    def removeObsolete(self): # removes obsolete dice (dice that win no MUs or only win MUs against other obsolete dice)\n",
    "        passList = []\n",
    "        count = 0\n",
    "        \n",
    "        for i in self.dice:\n",
    "            if i.wins > 0:\n",
    "                passList.append(i)\n",
    "            else:\n",
    "                count += 1\n",
    "            self.dice = passList\n",
    "        \n",
    "        if count > 0:\n",
    "            self.clearMatches()\n",
    "            self.fightAll()\n",
    "            self.removeObsolete()\n",
    "            \n",
    "    def removeNumber(self,number):\n",
    "        passList = []\n",
    "        for d in self.dice:\n",
    "            if number not in d.sides:\n",
    "                passList.append(d)\n",
    "        self.dice = passList\n",
    "            \n",
    "    def showMUs(self,die): # print every MU within the set for a given die\n",
    "        print(die.sides,end = \"\\t\")\n",
    "        print(\"Matchups\")\n",
    "        for d in self.dice:\n",
    "            winner,margin = Contest(die,d)\n",
    "            print(d.sides,end = \"\\t\")\n",
    "            if (winner == die) or (not winner):\n",
    "                print(\"+\" + str(margin))\n",
    "            else:\n",
    "                print(\"-\" + str(margin))\n",
    "                \n",
    "    def saveMUs(self,die): # print every MU within the set for a given die into txt file\n",
    "        MUfolder = directory + \"MUs/\" # MU txt folder\n",
    "        \n",
    "        try:\n",
    "            f = open(MUfolder + str(die.sides) + \".txt\", 'w')\n",
    "            \n",
    "            f.write(\"Matchup\\tValue\\n\")\n",
    "        \n",
    "            for d in self.dice:\n",
    "                winner,margin = Contest(die,d)\n",
    "                f.write(str(d.sides) + \"\\t\")\n",
    "                if (winner == die) or (not winner):\n",
    "                    f.write(\"+\" + str(margin))\n",
    "                else:\n",
    "                    f.write(\"-\" + str(margin))\n",
    "                f.write(\"\\n\")\n",
    "                    \n",
    "        finally:\n",
    "            f.close()\n",
    "            \n",
    "    def saveAllMUs(self):\n",
    "        for d in self.dice:\n",
    "            self.saveMUs(d)\n",
    "            \n",
    "    def tableMUs(self):\n",
    "        try:\n",
    "            f = open(\"MU Table.csv\",'w')\n",
    "            \n",
    "            f.write(\"Die\")\n",
    "            \n",
    "            for d in self.dice:\n",
    "                f.write(\"\\t\" + str(d.sides))\n",
    "            \n",
    "            for d in self.dice:\n",
    "                f.write(\"\\n\")\n",
    "                f.write(str(d.sides))\n",
    "                \n",
    "                for e in self.dice:\n",
    "                    f.write(\"\\t\")\n",
    "                    winner,margin = Contest(d,e)\n",
    "                    \n",
    "                    if (winner == d) or (not winner):\n",
    "                        f.write(\"+\" + str(margin))\n",
    "                    else:\n",
    "                        f.write(\"-\" + str(margin))\n",
    "                        \n",
    "        finally:\n",
    "            f.close()\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Player: # a player within a competitive scene with a main die\n",
    "    def __init__(self,dice):\n",
    "        self.dice = dice # set of dice to choose from\n",
    "        self.mainDie = random.choice(self.dice) # start with a random main die\n",
    "        self.attach = 5 # starting attachment value\n",
    "        #self.show()\n",
    "    \n",
    "    def show(self):\n",
    "        print(\"Main: \",end = \"\\t\")\n",
    "        print(self.mainDie.sides,end = \"\\t\")\n",
    "        print(self.attach)\n",
    "        \n",
    "    def changeMains(self): # pick a random new main\n",
    "        self.mainDie = random.choice(self.dice)\n",
    "        self.attach = 5 # reset attachment\n",
    "        \n",
    "    def lose(self): # if a player loses a fight, their attachment goes down\n",
    "        self.attach -= 1\n",
    "        if self.attach < 1: # change mains if attachment reaches 0\n",
    "            self.changeMains()\n",
    "    \n",
    "    def win(self):\n",
    "        if self.attach < 1000: #attachment cannot exceed 1000 (done to ensure metagame does not slow down due to inertia)\n",
    "            self.attach += 1\n",
    "        \n",
    "    def roll(self): # roll its main die\n",
    "        return self.mainDie.roll()\n",
    "    \n",
    "    def chooseMain(self,die):\n",
    "        self.mainDie = die"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Scene:# competitive scene full of players\n",
    "    def __init__(self,popSize,dice):\n",
    "        self.players = [] # players in scene\n",
    "        self.popSize = popSize # number of players in scene\n",
    "        self.dice = dice # set of dice available in scene\n",
    "        self.day = 0 # current generation (1 day per tournament)\n",
    "        \n",
    "        for i in range(self.popSize): # populate scene\n",
    "            self.players.append(Player(self.dice))\n",
    "            \n",
    "    def tournament(self): # each player fights 1 random other player\n",
    "        bracket = self.players.copy()\n",
    "        random.shuffle(bracket)\n",
    "        while len(bracket) > 0:\n",
    "            playerA = bracket.pop()\n",
    "            playerB = bracket.pop()\n",
    "            Fight(playerA,playerB)\n",
    "        \n",
    "            \n",
    "    def show(self):\n",
    "        for i in self.players:\n",
    "            i.show()\n",
    "            \n",
    "    def countDie(self,die): # count how many players currently main a given die\n",
    "        count = 0\n",
    "        for p in self.players:\n",
    "            if p.mainDie == die:\n",
    "                count += 1\n",
    "        return count\n",
    "            \n",
    "    def runSceneSim(self,duration,interval): # run simulation\n",
    "        try:\n",
    "            f = open(directory + \"SimulationData.txt\", 'w')\n",
    "            \n",
    "            f.write(\"Day\\t\")\n",
    "            for d in self.dice:\n",
    "                f.write(str(d.sides))\n",
    "                f.write(\"\\t\")\n",
    "            f.write(\"\\n\")\n",
    "            \n",
    "            for i in range(duration):\n",
    "                self.tournament()\n",
    "                if self.day % interval == 0:\n",
    "                    f.write(str(self.day))\n",
    "                    f.write(str(\"\\t\"))\n",
    "                    for d in self.dice:\n",
    "                        f.write(str(self.countDie(d)))\n",
    "                        f.write(\"\\t\")\n",
    "                    f.write(\"\\n\")\n",
    "                self.day += 1\n",
    "        finally:        \n",
    "            f.close()\n",
    "            print(\"done!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Bracket:\n",
    "    def __init__(self,bestOf,size,dice):\n",
    "        self.bestOf = bestOf\n",
    "        self.size = size\n",
    "        self.dice = dice\n",
    "        number = len(self.dice)\n",
    "        self.players = []\n",
    "        \n",
    "        for i in range(number):\n",
    "            self.players.append(Player(self.dice))\n",
    "            \n",
    "        for i in range(number):\n",
    "            p = self.players[i]\n",
    "            d = self.dice[i]\n",
    "            p.chooseMain(d)\n",
    "            \n",
    "    def show(self):\n",
    "        for p in self.players:\n",
    "            p.show()\n",
    "            \n",
    "    def tournament(self): \n",
    "        bracket = self.players.copy()\n",
    "        winBracket = []\n",
    "        loseBracket = []\n",
    "        dead = []\n",
    "        random.shuffle(bracket)\n",
    "        \n",
    "        while len(bracket) > self.size:\n",
    "            bracket.pop()\n",
    "        \n",
    "        winBracket, loseBracket = Split(bracket, self.bestOf)\n",
    "        \n",
    "        while (len(winBracket) != 1) or (len(loseBracket) != 1): \n",
    "            random.shuffle(winBracket)\n",
    "            random.shuffle(loseBracket)\n",
    "            \n",
    "            bracket = loseBracket.copy\n",
    "            loseBracket, dead = Split(bracket, self.bestOf)\n",
    "            \n",
    "            bracket = winBracket.copy\n",
    "            winBracket, bracket = Split(bracket, self.bestOf)\n",
    "            for p in bracket:\n",
    "                loseBracket.append(p)\n",
    "\n",
    "            random.shuffle(loseBracket)\n",
    "            \n",
    "            bracket = loseBracket.copy\n",
    "            loseBracket, dead = Split(bracket, self.bestOf)\n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Split(bracket, bestOf):\n",
    "    winners = []\n",
    "    losers = []\n",
    "    \n",
    "    while len(bracket) > 0:\n",
    "        playerA = bracket.pop()\n",
    "        playerB = bracket.pop()\n",
    "        winner,loser = Match(playerA,playerB,bestOf)\n",
    "        winners.append(winners)\n",
    "        losers.append(losers)\n",
    "        \n",
    "    return winners, losers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Contest(dieA,dieB): # analytical comparison between 2 dice\n",
    "    contests = 0\n",
    "    winsA = 0\n",
    "    lossA = 0\n",
    "    winsB = 0\n",
    "    lossB = 0\n",
    "    \n",
    "    dieA.play()\n",
    "    dieB.play()\n",
    "    \n",
    "    for a in dieA.sides:\n",
    "        for b in dieB.sides:\n",
    "            contests = contests + 1\n",
    "            if a>b:\n",
    "                winsA = winsA + 1\n",
    "                lossB = lossB + 1\n",
    "            elif b>a:\n",
    "                winsB = winsB + 1\n",
    "                lossA = lossA + 1\n",
    "                \n",
    "    dieA.possWins += winsA\n",
    "    dieA.possLosses += lossA\n",
    "    dieA.possContests += contests\n",
    "    \n",
    "    dieB.possWins += winsB\n",
    "    dieB.possLosses += lossB\n",
    "    dieB.possContests += contests\n",
    "    \n",
    "                \n",
    "    if winsA>winsB:\n",
    "        dieA.win()\n",
    "        dieB.lose()\n",
    "        return dieA,winsA-winsB\n",
    "    elif winsB>winsA:\n",
    "        dieA.lose()\n",
    "        dieB.win()\n",
    "        return dieB,winsB-winsA\n",
    "    else:\n",
    "        return False,0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Fight(playerA,playerB): # both players compete by rolling their main dice\n",
    "    rollA = playerA.roll()\n",
    "    rollB = playerB.roll()\n",
    "    \n",
    "    if rollA>rollB:\n",
    "        playerA.win()\n",
    "        playerB.lose()\n",
    "    elif rollB>rollA:\n",
    "        playerA.lose()\n",
    "        playerB.win()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Match(playerA,playerB,bestOf):\n",
    "    \n",
    "    targetScore = (bestOf+1)/2\n",
    "    scoreA = 0\n",
    "    scoreB = 0\n",
    "    \n",
    "    while (scoreA < targetScore) and (scoreB < targetScore):\n",
    "        if Game(playerA,playerB) == playerA:\n",
    "            scoreA += 1\n",
    "        else:\n",
    "            scoreB += 1\n",
    "            \n",
    "    if scoreA == targetScore:\n",
    "        return playerA,playerB\n",
    "    else:\n",
    "        return playerB,playerA\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Game(playerA,playerB):\n",
    "    \n",
    "    rollA = playerA.roll()\n",
    "    rollB = playerB.roll()\n",
    "    \n",
    "    while rollA == rollB:    \n",
    "        rollA = playerA.roll()\n",
    "        rollB = playerB.roll()\n",
    "    \n",
    "    if rollA>rollB:\n",
    "        return playerA\n",
    "    else:\n",
    "        return playerB"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#everyDie = AllDice()\n",
    "dice = AllDice() # generate dice\n",
    "\n",
    "dice.fightAll()\n",
    "dice.removeObsolete()\n",
    "#dice.show() # set of non-obsolete dice"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "compScene = Scene(500,dice.dice) # generate scene of players\n",
    "\n",
    "compScene.runSceneSim(10000000,1000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "compScene.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "object of type 'builtin_function_or_method' has no len()",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-35-7f347707ccc0>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mb\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mBracket\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m64\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mdice\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdice\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mb\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtournament\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<ipython-input-28-9397240ad6ca>\u001b[0m in \u001b[0;36mtournament\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m     36\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     37\u001b[0m             \u001b[0mbracket\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mloseBracket\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 38\u001b[1;33m             \u001b[0mloseBracket\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdead\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mSplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mbracket\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mbestOf\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     39\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     40\u001b[0m             \u001b[0mbracket\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mwinBracket\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m<ipython-input-29-9b72d18d28e1>\u001b[0m in \u001b[0;36mSplit\u001b[1;34m(bracket, bestOf)\u001b[0m\n\u001b[0;32m      3\u001b[0m     \u001b[0mlosers\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 5\u001b[1;33m     \u001b[1;32mwhile\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mbracket\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      6\u001b[0m         \u001b[0mplayerA\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mbracket\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      7\u001b[0m         \u001b[0mplayerB\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mbracket\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mTypeError\u001b[0m: object of type 'builtin_function_or_method' has no len()"
     ]
    }
   ],
   "source": [
    "b = Bracket(5,64,dice.dice)\n",
    "b.tournament()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
